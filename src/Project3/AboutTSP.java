package Project3;

import java.awt.Toolkit;

/**
 *<pre>
 *  Class           AboutTSP
 *  File            AboutTSP.java
 *  Description     An about page which displays information about the
 *                  traveling salesperson project
 *  Environment     PC, Windows 10, NetBeans IDE 8.2, jdk 1.8.0_131
 *  Date            5/27/2019
 *  History Log        
 *  @version        1.0.0
 *  @see            javax.swing.JFrame
 * </pre>
 */
public class AboutTSP extends javax.swing.JDialog 
{

    /**~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    *<pre>
    *	Constructor     AboutTSP()
    *	Description     Default constructor--creates form
    *   @see            java.awt.Toolkit
    *   @see            java.awt.Frame
    *   @param          modal--boolean, determines if the window remains active
    *                           and focused
    *   @param          parent--java.awt.Frame, top level window, has title
    *                           and border
    *	@author         <i>Joshua Watts</i>
    *	Date            5/27/2019
    *   History Log     
    *</pre>
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    public AboutTSP(java.awt.Frame parent, boolean modal) 
    {
        super(parent, modal);
        initComponents();
        //center form
        this.setLocationRelativeTo(null);
        //set ok button to default
        this.getRootPane().setDefaultButton(okJButton);
        //set icon 
        this.setIconImage(Toolkit.getDefaultToolkit().getImage
        ("src/Images/")); 
        //set title
        this.setTitle("Project #3--About Traveling Salesperson");
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        backgroundJPanel = new javax.swing.JPanel();
        aboutJTabbedPane = new javax.swing.JTabbedPane();
        aboutJPanel = new javax.swing.JPanel();
        bruteJScrollPane1 = new javax.swing.JScrollPane();
        bruteJTextArea1 = new javax.swing.JTextArea();
        aboutPicLabel = new javax.swing.JLabel();
        bruteForceJPanel = new javax.swing.JPanel();
        picJLabel = new javax.swing.JLabel();
        bruteJScrollPane = new javax.swing.JScrollPane();
        bruteJTextArea = new javax.swing.JTextArea();
        nearestJPanel = new javax.swing.JPanel();
        picJLabel1 = new javax.swing.JLabel();
        nearestJScrollPane = new javax.swing.JScrollPane();
        nearestJTextArea = new javax.swing.JTextArea();
        sortedJPanel = new javax.swing.JPanel();
        picJLabel2 = new javax.swing.JLabel();
        sortedJScrollPane = new javax.swing.JScrollPane();
        sortedJTextArea = new javax.swing.JTextArea();
        okJButton = new javax.swing.JButton();
        titleJLabel = new javax.swing.JLabel();
        warningJLabel = new javax.swing.JLabel();
        copyrightJLabel = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        backgroundJPanel.setBackground(new java.awt.Color(153, 204, 255));

        aboutJPanel.setBackground(new java.awt.Color(153, 204, 255));

        bruteJTextArea1.setEditable(false);
        bruteJTextArea1.setColumns(20);
        bruteJTextArea1.setFont(new java.awt.Font("SansSerif", 0, 12)); // NOI18N
        bruteJTextArea1.setLineWrap(true);
        bruteJTextArea1.setRows(5);
        bruteJTextArea1.setText("The traveling salesman problem is a problem in which you are given a set of cities and you must find the most efficient (shortest distance) to visit each city and end up back at your starting city. This problem has been posed for a long time but no perfect solution has been found. There is a method that gaurantees you will find the shortest path, but it has an O(n!) growth function, so it is unreasonable for moderate to large numbers of cities. Two other methods are explored in this progeam, the nearest neighbor algorith and the sorted edge algorithm.");
        bruteJTextArea1.setWrapStyleWord(true);
        bruteJScrollPane1.setViewportView(bruteJTextArea1);

        aboutPicLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/Washington.png"))); // NOI18N

        javax.swing.GroupLayout aboutJPanelLayout = new javax.swing.GroupLayout(aboutJPanel);
        aboutJPanel.setLayout(aboutJPanelLayout);
        aboutJPanelLayout.setHorizontalGroup(
            aboutJPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, aboutJPanelLayout.createSequentialGroup()
                .addGap(4, 4, 4)
                .addComponent(aboutPicLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 296, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(bruteJScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 303, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        aboutJPanelLayout.setVerticalGroup(
            aboutJPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(aboutJPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(aboutJPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, aboutJPanelLayout.createSequentialGroup()
                        .addComponent(aboutPicLabel)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addComponent(bruteJScrollPane1))
                .addContainerGap())
        );

        aboutJTabbedPane.addTab("TSP", aboutJPanel);

        bruteForceJPanel.setBackground(new java.awt.Color(153, 204, 255));

        picJLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/BruteForce.png"))); // NOI18N

        bruteJTextArea.setEditable(false);
        bruteJTextArea.setColumns(20);
        bruteJTextArea.setFont(new java.awt.Font("SansSerif", 0, 12)); // NOI18N
        bruteJTextArea.setLineWrap(true);
        bruteJTextArea.setRows(5);
        bruteJTextArea.setText("The brute force algorithm is by far the most accurate method to get the most efficient path, but it is also the most inefficient. This algorithm has a O(n!) growth function, which means it gets way too large way too quickly. This algorithm works by finding all possible paths in a given graph, then finds the cost of each path. The one which has the cheapest cost is the most most effieicnt route.");
        bruteJTextArea.setWrapStyleWord(true);
        bruteJScrollPane.setViewportView(bruteJTextArea);

        javax.swing.GroupLayout bruteForceJPanelLayout = new javax.swing.GroupLayout(bruteForceJPanel);
        bruteForceJPanel.setLayout(bruteForceJPanelLayout);
        bruteForceJPanelLayout.setHorizontalGroup(
            bruteForceJPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(bruteForceJPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(picJLabel)
                .addGap(18, 18, 18)
                .addComponent(bruteJScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 289, Short.MAX_VALUE)
                .addContainerGap())
        );
        bruteForceJPanelLayout.setVerticalGroup(
            bruteForceJPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, bruteForceJPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(bruteForceJPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(picJLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 211, Short.MAX_VALUE)
                    .addComponent(bruteJScrollPane))
                .addContainerGap())
        );

        aboutJTabbedPane.addTab("Brute Force", bruteForceJPanel);

        nearestJPanel.setBackground(new java.awt.Color(153, 204, 255));

        picJLabel1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/Neighbor.png"))); // NOI18N

        nearestJTextArea.setEditable(false);
        nearestJTextArea.setColumns(20);
        nearestJTextArea.setFont(new java.awt.Font("SansSerif", 0, 12)); // NOI18N
        nearestJTextArea.setLineWrap(true);
        nearestJTextArea.setRows(5);
        nearestJTextArea.setText("The Nearest Neighbor algorithm is much more effieient than the brute force approach but it does not always yield the best route. This algorithm works by staring at an arbitrary vertex then traveling to the next vertice which is closest to the first one, after each vertex is visited it gets marked with a boolean value isVisited. From each vertice you reach you find the next closest which is not yet visited. This gets repeated until all you reach the starting vertice again, which means the cycle is complete. In the image, the path is started at vertice A, then it travels to the next closest which is B, each time one is visited it gets marked as visited. The path then goes to vertice D and then tries to go to the next closest, which is A, but since A is already visited ti will go to vertice C.");
        nearestJTextArea.setWrapStyleWord(true);
        nearestJScrollPane.setViewportView(nearestJTextArea);

        javax.swing.GroupLayout nearestJPanelLayout = new javax.swing.GroupLayout(nearestJPanel);
        nearestJPanel.setLayout(nearestJPanelLayout);
        nearestJPanelLayout.setHorizontalGroup(
            nearestJPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(nearestJPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(picJLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(nearestJScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 286, Short.MAX_VALUE)
                .addContainerGap())
        );
        nearestJPanelLayout.setVerticalGroup(
            nearestJPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(nearestJPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(nearestJPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(nearestJPanelLayout.createSequentialGroup()
                        .addComponent(picJLabel1)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addComponent(nearestJScrollPane))
                .addContainerGap())
        );

        aboutJTabbedPane.addTab("Nearest Neighbor", nearestJPanel);

        sortedJPanel.setBackground(new java.awt.Color(153, 204, 255));

        picJLabel2.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/Sorted.png"))); // NOI18N

        sortedJTextArea.setEditable(false);
        sortedJTextArea.setColumns(20);
        sortedJTextArea.setFont(new java.awt.Font("SansSerif", 0, 12)); // NOI18N
        sortedJTextArea.setLineWrap(true);
        sortedJTextArea.setRows(5);
        sortedJTextArea.setText("Just like the nearest neighbor, the sorted edge algorithm is more effieicnt than the brute force approach but will not always yield the best result. The sorted edge algorithm works by sorting all the edges in increasing order by their weight. The first edge (smallest) is added to the path, then the next smallest edge is added, each time an edge is added you must check if the vertice is full (2 edges) and the cycle is not completed too early. The image demonstrates the middle of this process, B-D was added, then C-E, then A-B, all without problem, but once A-D gets added the method which checks for an early cycle gets flagged, in the picture you can see a cycle is formed with A-B-D, this does not include all verticies so A-D must be removed from the graph.");
        sortedJTextArea.setWrapStyleWord(true);
        sortedJScrollPane.setViewportView(sortedJTextArea);

        javax.swing.GroupLayout sortedJPanelLayout = new javax.swing.GroupLayout(sortedJPanel);
        sortedJPanel.setLayout(sortedJPanelLayout);
        sortedJPanelLayout.setHorizontalGroup(
            sortedJPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(sortedJPanelLayout.createSequentialGroup()
                .addGap(52, 52, 52)
                .addComponent(picJLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 55, Short.MAX_VALUE)
                .addComponent(sortedJScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 273, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        sortedJPanelLayout.setVerticalGroup(
            sortedJPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(sortedJPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(sortedJPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(sortedJPanelLayout.createSequentialGroup()
                        .addComponent(picJLabel2)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addComponent(sortedJScrollPane))
                .addContainerGap())
        );

        aboutJTabbedPane.addTab("Sorted Edge", sortedJPanel);

        okJButton.setBackground(new java.awt.Color(153, 255, 255));
        okJButton.setFont(new java.awt.Font("SansSerif", 0, 12)); // NOI18N
        okJButton.setMnemonic('o');
        okJButton.setText("Ok");
        okJButton.setToolTipText("Close the about form");
        okJButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                okJButtonActionPerformed(evt);
            }
        });

        titleJLabel.setFont(new java.awt.Font("Rockwell Condensed", 0, 32)); // NOI18N
        titleJLabel.setText("About Traveling Salesman Problem");

        warningJLabel.setText("Warning. Do not copy this program.");

        copyrightJLabel.setText("©2019 Josh Watts");

        javax.swing.GroupLayout backgroundJPanelLayout = new javax.swing.GroupLayout(backgroundJPanel);
        backgroundJPanel.setLayout(backgroundJPanelLayout);
        backgroundJPanelLayout.setHorizontalGroup(
            backgroundJPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(backgroundJPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(backgroundJPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(aboutJTabbedPane)
                    .addGroup(backgroundJPanelLayout.createSequentialGroup()
                        .addComponent(warningJLabel)
                        .addGap(111, 111, 111)
                        .addComponent(okJButton, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(copyrightJLabel))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, backgroundJPanelLayout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(titleJLabel)))
                .addContainerGap())
        );
        backgroundJPanelLayout.setVerticalGroup(
            backgroundJPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(backgroundJPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(titleJLabel)
                .addGap(1, 1, 1)
                .addComponent(aboutJTabbedPane, javax.swing.GroupLayout.PREFERRED_SIZE, 261, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(backgroundJPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(okJButton, javax.swing.GroupLayout.DEFAULT_SIZE, 39, Short.MAX_VALUE)
                    .addComponent(warningJLabel)
                    .addComponent(copyrightJLabel))
                .addContainerGap())
        );

        aboutJTabbedPane.getAccessibleContext().setAccessibleName("");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(backgroundJPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(backgroundJPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    *<pre>
    *	Event Handler	okJButtonActionPerformed
    *	Description     dispose of the about form
    *   @param          evt--java.awt.event.ActionEvent
    *	@see            java.awt.event.ActionEvent
    *	@author         <i>Joshua Watts</i>
    *	Date            5/27/2019
    *   History Log     
    *</pre>
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    private void okJButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_okJButtonActionPerformed
        //close the about form
        this.dispose();
    }//GEN-LAST:event_okJButtonActionPerformed

//    public static void main(String args[]) {
//        /* Set the Nimbus look and feel */
//        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
//        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
//         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
//         */
//        try {
//            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
//                if ("Nimbus".equals(info.getName())) {
//                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
//                    break;
//                }
//            }
//        } catch (ClassNotFoundException ex) {
//            java.util.logging.Logger.getLogger(AboutTSP.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
//        } catch (InstantiationException ex) {
//            java.util.logging.Logger.getLogger(AboutTSP.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
//        } catch (IllegalAccessException ex) {
//            java.util.logging.Logger.getLogger(AboutTSP.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
//        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
//            java.util.logging.Logger.getLogger(AboutTSP.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
//        }
//        //</editor-fold>
//
//        /* Create and display the dialog */
//        java.awt.EventQueue.invokeLater(new Runnable() {
//            public void run() {
//                AboutTSP dialog = new AboutTSP(new javax.swing.JFrame(), true);
//                dialog.addWindowListener(new java.awt.event.WindowAdapter() {
//                    @Override
//                    public void windowClosing(java.awt.event.WindowEvent e) {
//                        System.exit(0);
//                    }
//                });
//                dialog.setVisible(true);
//            }
//        });
//    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel aboutJPanel;
    private javax.swing.JTabbedPane aboutJTabbedPane;
    private javax.swing.JLabel aboutPicLabel;
    private javax.swing.JPanel backgroundJPanel;
    private javax.swing.JPanel bruteForceJPanel;
    private javax.swing.JScrollPane bruteJScrollPane;
    private javax.swing.JScrollPane bruteJScrollPane1;
    private javax.swing.JTextArea bruteJTextArea;
    private javax.swing.JTextArea bruteJTextArea1;
    private javax.swing.JLabel copyrightJLabel;
    private javax.swing.JPanel nearestJPanel;
    private javax.swing.JScrollPane nearestJScrollPane;
    private javax.swing.JTextArea nearestJTextArea;
    private javax.swing.JButton okJButton;
    private javax.swing.JLabel picJLabel;
    private javax.swing.JLabel picJLabel1;
    private javax.swing.JLabel picJLabel2;
    private javax.swing.JPanel sortedJPanel;
    private javax.swing.JScrollPane sortedJScrollPane;
    private javax.swing.JTextArea sortedJTextArea;
    private javax.swing.JLabel titleJLabel;
    private javax.swing.JLabel warningJLabel;
    // End of variables declaration//GEN-END:variables
}
